#!/usr/bin/perl

# aws-list-ec2-sec-groups
#
# Extract useful information from aws ec2 describe instances
# Requires configured aws tool
#
# Version 0.0.2

use strict;
use warnings;

BEGIN
{
  use File::Spec;
  use File::Basename qw[];
  use Cwd 'abs_path';

  my $APP_BINPATH = File::Basename::dirname( abs_path( $0 ) );
  unshift(@INC, $APP_BINPATH);

  my @list = File::Spec->splitdir($APP_BINPATH);
  pop @list;
  push @list, qq(lib);

  my $APP_LIBPATH = join('/', @list);
  unshift(@INC, $APP_LIBPATH);
  push @INC, $APP_BINPATH . qq(/lib);
  undef $APP_LIBPATH;
  undef $APP_BINPATH;
}

use Getopt::Long;
use FileHandle;
use JSON;
use Data::Dumper;

{

  my $opt = {
                'TOOL_NAME'             => qq(aws-list-ec2-sec-groups),
                'TOOL_DESC'             => qq(Lists AWS EC2 security groups),
                'TOOL_VER_MAJOR'        => 0,
                'TOOL_VER_MINOR'        => 0,
                'TOOL_VER_PATCH'        => 2,
                'group_id'              => undef,
                'group_name'            => undef,
                'single_security_group' => 0,
                'with_tags'             => 0,
                'sec_fencer'            => 0,
                'help'                  => 0,
            };

  $opt->{'TOOL_FULL_ID'} = $opt->{'TOOL_NAME'} . qq( ver ) . $opt->{'TOOL_VER_MAJOR'} . qq(.) . $opt->{'TOOL_VER_MINOR'} . qq(.) . $opt->{'TOOL_VER_PATCH'};

  my $ret = GetOptions(   "with-tags"     => \$opt->{'with_tags'},
                          "group-id=s"    => \$opt->{'group_id'},
                          "group-name=s"  => \$opt->{'group_name'},
                          "sec-fencer"    => \$opt->{'sec_fencer'},
                          "help"          => \$opt->{'help'}
                      );

  display_help_and_exit($opt) if ($opt->{'help'} || !$ret);
  display_and_exit(-1, qq(Parameters --group-id and --group-name cannot be used together)) if (!isEmpty($opt->{'group_id'}) && !isEmpty($opt->{'group_name'}));
  $opt->{'single_security_group'} = 1 if (!isEmpty($opt->{'group_id'}) || !isEmpty($opt->{'group_name'}));

  my $sec_groups_list_ptr = undef;
  ($ret, $sec_groups_list_ptr) = readFile("aws ec2 describe-security-groups|");
  display_and_exit(-1, qq(Failed to fetch security groups from AWS: ) . $sec_groups_list_ptr) if (!$ret);

  my $sec_groups_list = undef;
  ($ret, $sec_groups_list) = fromJSON($$sec_groups_list_ptr);
  display_and_exit(-1, qq(AWS security groups do not appear to be a JSON: $sec_groups_list)) if (!$ret);
  display_and_exit(-1, qq(JSON object does not have SecurityGroups array as the top level element)) if (!defined $sec_groups_list->{'SecurityGroups'});

  my @all_security_groups = ();

  foreach my $this_sec_group (@{$sec_groups_list->{'SecurityGroups'}})
    {
      my $this_sg = undef;
      next if (!isEmpty($opt->{'group_id'})   && $opt->{'group_id'} ne $this_sec_group->{'GroupId'});
      next if (!isEmpty($opt->{'group_name'}) && $opt->{'group_name'} ne $this_sec_group->{'GroupName'});

      $this_sg->{'GroupName'} = $this_sec_group->{'GroupName'};
      $this_sg->{'GroupId'}   = $this_sec_group->{'GroupId'};

      my $tags = undef;
      foreach my $this_tag (@{$this_sec_group->{'Tags'}})
        {
          $tags->{$this_tag->{'Key'}} = $this_tag->{'Value'};
        }
      $this_sg->{'Tags'} = $tags if ($opt->{'with_tags'});
      $this_sg->{'SecFencerEnabled'}  = $tags->{'sec_fencer_enabled'}  if (!isEmpty($tags->{'sec_fencer_enabled'}));
      $this_sg->{'SecFencerPolicies'} = $tags->{'sec_fencer_policies'} if (!isEmpty($tags->{'sec_fencer_policies'}));

      my @all_rules = ();
      my @sec_fencer_rules = ();
      foreach my $this_permission (@{$this_sec_group->{'IpPermissions'}})
        {
          my $this_rule = {
                            'Port'      => $this_permission->{'FromPort'},
                            'Protocol'  => $this_permission->{'IpProtocol'},
                          };
          my @all_cidrs = ();
          foreach my $this_cidr (@{$this_permission->{'IpRanges'}})
            {
              #print "inside ranges\n";
              if ($opt->{'sec_fencer'})
                {
                  my $this_fencer_rule = {
                                            'Port'      => $this_rule->{'Port'},
                                            'Protocol'  => $this_rule->{'Protocol'},
                                            'Cidr'      => $this_cidr->{'CidrIp'},
                                          };
                  push @sec_fencer_rules, $this_fencer_rule;
                }
              else
                {
                  push @all_cidrs, $this_cidr->{'CidrIp'};
                }
            }
          if (!$opt->{'sec_fencer'})
            {
              $this_rule->{'AllowFromCidrListIpV4'} = \@all_cidrs if (scalar @all_cidrs);
              push @all_rules, $this_rule;
            }
        }
      if ($opt->{'sec_fencer'})
        {
          $this_sg->{'SecFencerAllowFromCidrIpV4'} = \@sec_fencer_rules if (scalar @sec_fencer_rules);
        }
      else
        {
          $this_sg->{'AllowRules'} = \@all_rules;
        }
      push @all_security_groups, $this_sg;

    }

  if (my $total_sec_groups = scalar @all_security_groups)
    {
      my $resp = undef;
      my $ptr  = \@all_security_groups;
      $ptr = $all_security_groups[0] if ($total_sec_groups == 1 && $opt->{'single_security_group'});
      ($ret, $resp) = toJSON($ptr, { 'pretty' => 1});
      print $resp;
    }
  exit(0);
}

sub readFile
{
  my $fname = shift @_;
  my $txt = '';
  my $ret = 0;

  my $fh = FileHandle->new($fname);
  if (defined $fh)
    {
      while (my $line = <$fh>) { $txt .= $line; }
      $fh->close();
      $ret = 1;
    }
  return ($ret, \$txt);
}

sub isEmpty
{
  my $a = shift @_;
  my $r = 0;

  return 1 if (!defined $a);
  $r = 1 if (($a eq "") || ($a =~ m/^\s+$/g));

  return $r;
}

sub fromJSON
{
  my $txt = shift @_;

  return (0, qq(Received an undef)) if (isEmpty($txt));
  my $json = JSON->new->utf8->allow_nonref;

  my $ptr = undef;
  eval { $ptr = $json->decode($txt); };
  return (0, $@) if ($@);
  return (1, $ptr);
}

sub toJSON
{
  my $ptr = shift @_;
  my $is_pretty = shift @_;

  return (0, qq(Received an undef)) if (!defined $ptr);

  my $json = JSON->new->utf8->allow_nonref;
  return (1, $json->pretty(1)->encode($ptr)) if ($is_pretty);
  return (1, $json->encode($ptr));
}

sub removeSpaces
{
  my $txt = shift @_;
  return '' if (isEmpty($txt));

  $txt =~ s/\s+//g;

  return $txt;
}

sub display_and_exit
{
  my $code = shift @_;
  my $msg = shift @_;

  $msg = '' if (isEmpty($msg));
  $code = -1 if (isEmpty($code));

  printf "$msg\n";
  exit($code);
}

sub display_help_and_exit
{
  my $opt = shift @_;

  foreach my $k ( keys %$opt) { $opt->{$k} = qq(undefined) if (isEmpty($opt->{$k})); }

  printf("\n%s - %s\n\n", $opt->{'TOOL_FULL_ID'}, $opt->{"TOOL_DESC"});
  printf("Options:\n\n");
  printf("      --group-id=<id>     Display rule for security group <id>\n");
  printf("                          Default: all known groups\n");
  printf("      --group-name=<name> Display rules for security group <name>\n");
  printf("                          Default: all security groups\n");
  printf("      --with-tags         Include all tags assigned groups\n");
  printf("                          Default: no\n");
  printf("      --sec-fencer        Display result in Sec Fencer format\n");
  printf("                          Default: no\n");
  printf("      --help              This help\n\n");
  printf("This tool relies on pre-configured aws utility\n\n");

  exit(0);

}
